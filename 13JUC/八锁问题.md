# 八锁问题
- 1、一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其他的线程只能等待，换句话说，某一个时刻内，只能由唯一一个线程去访问这些synchronized方法。
即：锁如果是当前对象this，被锁后，其他的线程都不能进入到当前对象的其他的synchronized方法。
- 2、普通方法和同步锁无关
- 3、不同对象中的synchronized方法的锁对象不同。
- 4、所有的非静态同步方法用的都是同一个锁，即实例对象本身
- 5、synchronized实现同步的基础：Java中每一个对象都可以作为锁：
 >- |-对于普通的同步方法，锁的是当前实例对象，锁的是当前对象的this，
 >- |-对于同步方法块，锁的是synchronzied括号里配置的对象
 >- |-对于静态同步方法，锁的是当前Class对象
- 6、当一个线程视图访问同步代码块时，首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以无须等待该实例对象以获取锁的非静态同步方法释放锁就可以获取他们自己的锁。
- 7、所有的静态同步方法用的也是同一把锁-类对象本身：如果两把锁是两个不同的对象，那么静态同步方法也非静态同步方法之间是不会由竞态条件的。但是一旦 一个竞态同步方法获取锁之后，其他的竞态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的竞态同步方法之间还是不同的实例对象的竞态方法之间，只要他们是同一个类的实例对象。