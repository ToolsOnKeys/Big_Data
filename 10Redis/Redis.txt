Redis
	
#技术分类：
1、解决功能性问题：
Java、Servlet、Jsp、Tomcat、RDBMS、JDBC、Linux、Svn等
2、解决扩展性的问题：
Spring、SpringMVC、SpringBoot、Hibernate、MyBatis等
3、解决性能的问题：
NoSQL、Java多线程、Nginx、MQ、ElasticSearch、Hadoop等
	
#WEB1.0
数据访问量很有限，用一夫当关的高性能的单节点服务器可以解决大部分问题
#WEB2.0
用户访问量大幅度提升，同时产生了大量的用户数据，加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。
#解决服务器CPU内存压力
注：Session共享问题如何解决？
1、存在Cookie中：此方案需要将Session数据以Cookie的形式存在客户端，不安全，网络负担效率低
2、存在文件服务器或者是数据库里：此方案会导致大量的IO操作，效率低
3、Session复制：此种方案会导致每个服务器之间必须将Session广播到集群内的每个节点，Session数据会冗余，节点越多浪费越大，存在广播风暴问题
4、存在Redis中：目前看来，此种方案是最好的。将Session数据存在内存中，每台服务器都从内存中读取数据，速度快，结构还相对简单。
	
#NoSQL数据库概述：
1、NoSQL：泛指非关系型数据库。
NoSQL不依赖于业务逻辑方式存储，而是简单的key-value模式存储。因此大大增加了数据库的扩展能力
2、NoSQL的特点：
不遵循SQL标准、不支持ACID、远超于SQL的性能
3、NoSQL的使用场景
对数据的高并发的读写
海量数据的读写
4、NoSQL的不适用场景
需要事务的支持
基于sql的结构化查询存储，处理复杂的关系，需要及时查询
5、建议：用不着sql的和用了sql也不行的情况，考虑使用NoSQL
	
#常用的缓存数据库
1、Memcached：最早出现的NoSQL数据库，数据都在内存中，一般不持久化，请支持简单的key-value模式，一般作为缓存数据库辅助持久化数据库。
2、Redis：都在内存中，支持持久化，主要用作备份恢复、不仅支持kv，还支持多种数据类型（list、set等），一般作为缓存数据库辅助持久化数据库
3、mongoDB：靠性能、开源、模式自由的文档型数据库；持久化、有kv同时对value提供丰富的查询功能、支持二进制等大型数据独显、可以根据数据的特点替代rdbms，称为独立的数据库。或者配合RDBMS存储特定的数据。
4、HBASE：列式数据库
5、Cassandra：列式
Neo4j
	
#Redis的5大数据类型：
1、String：基本的数据类型，一个key，一个value；是二进制安全的。意味着Redis的String可以包含任何数据；一个value最多可以是512M
注：incr key操作的原子性：所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何context switch（切换到别的线程），在单线程中，能够在单挑指令中完成的操作都可以认为是原子操作。因为中断只能发生在指令之间；在多线程中，不能被其他进程（线程）大段的操作就叫做原子操作；Redis单指令的原子性主要得益于Redis的单线程
2、List
①、单键多值
②、Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或者尾部
③、他的底层世界是个双向链表们对于两端的操作性能很高，通过索引小标的错中间的节点性能会较差。
3、Set
①、Redis set对外提供的功能于list雷士是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据是，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。
②、Redis的Set是string类型的无需集合。他底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。
4、Hash
①、Redis hash是一个键值对集合。
②、Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
③、类似于Java里面的Map<String,Object>
④、通过key+field就可以操作对应的属性数据，即不需要重复存在的数据，也不会带来序列化和并发修改控制的问题。
5、zset
①、Redis有序集合zset和普通集合set非常现实，是一个没有重复元素的字符串集合。不同之处就是有序集合的每个成员都关联了一个评分，这个评分被用来按照从最低分到最高峰的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。
②、因为元素是有序的，所以你也可以很快的根据评分或者次序来获取一个庞伟的元素。访问有序集合的中间元素也是非常快的。
	
#Redis的相关配置
1、include
类似jsp中的include，多实列的情况可以把公用的配置文件提取出来。
2、ip地址的绑定bind
①、默认情况是bind=127.0.0.1只能接受本机的访问请求。
②、不写的情况下，无限制接受任何ip地址的访问
③、生产环境肯定要谢你应用服务器的地址
④、如果开启了protected-mode，那么在没有谁顶band，ip且没有设密码的情况下，Redis只允许接受本机的相应。
3、tcp-backlog
①、可以理解是一个请求到达后至到接受进程处理前的队列。
②、backlog队列综合=未完成三次握手队列+已经完成三次握手队列
③、高并发华宁tcp-backlog设置值跟超时时限内的Redis吞吐量决定。
4、timeout
一个空闲的客户端维持多少秒会关闭，0为永不关闭。

	
#Redis中事务的定义：
Redis事务是一个单独的隔离操作：食物中的所有命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis事务的主要所用就是串联多个命令防止别的命令插队。
	
#Redis事务的操作
1、从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入exec后，redis才会将之前的命令队列中的命令一次执行。
2、组队的过程中可以通过discard来放弃组队

#Redis事务中的错误处理：
1、组队中某个命令出现了报告错误，执行时某个的所有队列都会被徐晓
2、如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。

#Redis事务的使用
1、Watch key
在执行multi之前，限制性watch key1 【key2】，可以监视一个或者多个key，如果在事务执行之前这个key被其他命令所改动，那么事务将被打断。
2、unwatch
取消watch命令对所有key的监视
如果在执行watch命令之后，exec命令或discard命令向北执行了的话，那么就不需要在执行unwatch了
	
#Redis事务的三特性
1、单独的隔离操作
事务中所有的命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端送来的命令请求所打断
2、没有隔离级别的概念：
队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到“
3、不保证原子性
Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。
	
#Redis持久化-RDB
1、在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时时间快照文件直接督导内存里。
2、备份是如何执行的
Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，在用这个临时文件替换上次持久化的文件。整个过程中，主进程时不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点时最后一次持久化后的数据可能丢失。
3、fork
在linux程序中，fork（）会产生一个和父进程完全相同的子进程，当子进程在此后多会exec系统调用，处于效率考虑，linux中引入了”写时复制技术“，一般情况下父进程和子进程会公用同一段物理内存，只有进程空间的隔断的内容要发生变化时，才会将父进程的内容复制一份给子进程。
	
#Redis持久化-AOF
1、一日至的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读指令不记录），只许追加文件当不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话会根据日志文件的内容，将写指令从前到后执行一次已完成数据的恢复工作。
2、AOF文件的故障备份
AOF的备份机制和性能虽然和RDB不同，但是备份和恢复的操作同RDB一样，都是拷给备份文件，需要回复是再拷贝到Redis的工作目录下，重启加载即可。
3、AOF文件故障恢复
如遇到AOF文件顺坏，可通过
redis-check-aof --fix appendonly.aof
4、AOF的优缺点
①、优点：备份机制更稳健，丢失数据概率更低；可读的日志文本，通过操作AOF稳健，可以处理误操作。
②、缺点：比起RDB占用更多的磁盘空间；恢复备份速度较慢；每次读写都通的话，有一定的性能压力。
	
#RDB和AOF用哪个好
1、官方推荐两个都启用
2、如果对数据不敏感，可以选单独用RDB
3、不建议单独用AOF，因为可能出现BUG
4、如果只是做纯内存缓存，可以都不用。
	#Redis主从复制
1、定义：主从复制就是主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave已读为主
2、主从复制的目的：读写分离，性能扩展；容灾快速恢复
3、主从配置：
①、
include /myredis/redis.conf  
pidfile "/var/run/redis_6380.pid" 
port 6380 
dbfilename "dump_6380.rdb" 
daemonize yes
#slave-priority 80 slave称为Master的优先级
②、info replication 打印主从复制的相关信息
③、slaveof <ip> <port> 称为某个实列的从服务器
4、主从复制的原理
①、每次从机联通后，都会给主机发送sync指令
②、主机立刻进行存盘操作，发送RDB文件给从机
③、从机收到RDB文件后，进行全盘加载
④、之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令
5、哨兵模式 sentinel：Master断开，如何让slave自动成为主机（手动调整的方式是将一个从机通过slaveof no one的方式转变为主机，然后将其他从机的主机调整为新的主机）
①、目的和结果：能够后台监控主机是否故障，如果故障了根据投票机制会自动选择一个从机转为主机，并调整其他从机的主机，以保证redis数据库的无断电异常。
②、哨兵配置
|-在/myredis目录下新建sentinel.conf文件
sentinel monitor mymaster 127.0.0.1 6379 1
其中mymaster为监控对象起的服务器的名称，1为哨兵同意数量
|-启动哨兵
redis-sentinel /myredis/sentinel.conf
	
#集群
1、定义：Redis集群实现了Redis的水平扩展，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N；Redis集群通过分区来提供一定程度的可用性：即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。
2、集群的操作：
①、进入客户端：redis-cli -c -p 端口号
②、查看集群的主从信息：cluster nodes
③、slots：槽
④、集群中如何录入值：
|-在redis-cli 每次录入、查询键值，redis都会计算出该key应该送入的插槽，如果不是该客户端对应的服务器的插槽，redis就会报错，并告知应前往的redis实例地址和端口
|-redis-cli客户端提供了-c参数实现了自动重定向。
|-不在一个slot下的键值，是不能使用mget，mset等多键操作的
|-可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。
⑤、计算key应该防止在哪个slot上：cluster keyslot 键
⑥、返回slot目前包含的键值对数量：cluster countkeysinslot 键
⑦、返回slot中的键值：cluster getkeysinslot 槽位 数量
3、集群的优缺点：
|-优点：实现扩容，分摊压力，无中心配置，相对简单
|-多键操作时不被支持的；多键的Redis事务时不被支持的；lua脚本不被支持；