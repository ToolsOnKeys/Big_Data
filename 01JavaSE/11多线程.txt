#几个概念：
|-程序：为了完成某个认为或功能而选择一种改编成语言编写的一组指令的集合
|-软件：程序+程序运行期间需要的其他的素材等，一个软件至少包含一个程序
|-进程：一个程序的一次运行。操作系统是以进程为单位分配系统资源，进程之间的内存是独立的，进程之间的切换，通信成本比较高。
|-线程：一个进程中其中一条执行路径。一个进程至少一个线程。线程是CPU调度的最小单位。同一个进程中的多个线程是可以共享内存，但是每一个线程的占空间是独立的。
#启动线程的两种方式：
1、继承java.lang.Thread类
①、编写线程类继承Thread类
②、必须重写public void run（）方法。
③、创建线程类的对象
④、调用线程类对象的start（）方法启动线程
2、实现java.lang.Runnable接口
①、编程线程类实现Runnable接口
②、重写run（）
③、创建Runnable接口的实现类的对象
④、创建Thread类的对象，并且把Runnable接口的实现类的对象作为对象传给Thread类
⑤、调用Thread类的对象过的start（）启动线程。
#Thread类的常用方法
1、构造器
|-Thread（）
|-Thread（String name）
|-Thread（Runnable target）
|-Thread（Runnable target，String name）
2、其他方法
|-start（）：启动线程
|-run（）：编写线程体，子类必须重写
|-sleep（时间）：线程休眠
|-yield（）：暂停当前线程
|-join（）：线程加塞，被加塞的线程必须等到加塞的线程执行完才能继续
|-join（时间）：被加塞的线程要等xxx时间之后才有机会被执行
|-setName（xxx）：设置线程名称
|-getName（）：获取线程名称
|-setPriority（等级）：设置线程优先级，遇险记的等级范围是【1，10】.Thread类中有三个常量：MAX_PROPRITY,MIN_PRIORITY,NORM_PRIORITY
|-getPriority（）：获取线程优先级
|-interrupt（）：中断线程的休眠
|-setDaemon（true）：设置某个线程为守护线程。当其被守护线程结束了，守护线程自己就会自动结束。
|-currenThread（）：获取正在执行当前代码的线程对象。
#关键字volatile
修饰符，修饰成员变量。当这个成员变量被频繁的访问时，Java编译器会做优化，会在寄存器中缓存这个变量的值，而不去及时主存中读取，或者说贮存的修改和混村中的值没有及时同步，这个时候我们变量值已经修改了，但是程序可能仍然用之前缓存的值进行计算和判断，导致效果有问题。加了volatile，就会施得每一次使用的这个变量的值时，都会与主存保持一致。
#线程安全
1、需要线程安全的原因
①、存在多个线程同时运行某段代码的模板
②、存在几个线程使用共享的数据，这个共享数据可能是访问和修改的同一个变量，访问和修改同一个文件，访问或修改同一个数据库的同一条记录。
③、多条语句操作这个共享数据。
2、保证线程安全的两种方式：
①、同步代码块：
synchronized（锁对象/监视器对象）{
需要同步的代码块；
}
|-锁对象：类型没有限制，可以是任意引用数据类型的对象都可以作为锁对象；但是必须保证使用共享数据的多个线程必须使用同一个锁对象。
|-同步：使用同一个锁对象的多个线程，同时只能有一个线程持有锁对象，只有持有锁对象的线程才能执行它的线程体，没有获取锁对象的线程只能等着。
②、同步方法
【其他修饰符】 synchronized 返回值类型 方法名（【形参列表】）【throws 异常列表】{
}
|-锁对象：非静态方法this，静态方法当前类的Class对象。
#线程通信
1、调用wait和notify方法需要注意的细节：
①、wait方法与notify方法必须要有同一个锁对象调用。因为对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程
②、wait方法与notify方法是属于Object类的方法的。因为锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
③、wait方法与notify方法必须要在同步代码块或者同步方法中使用。因为必须要通过锁对象调用这两个方法。
#线程的生命周期
线程的生命周期分为五种状态：新建，就绪，运行，阻塞，死亡。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。
#sleep和wait有什么区别？
1、sleep不是放锁，wait释放锁
2、sleep是Thread类的静态方法，wait是Object类的方法，因为wait方法必须有锁对象调用，而锁对象可能是任意类型的对象，所以只能声明在Object中
3、sleep一般指定休眠的时间，到了恢复到就绪状态。wait可以设置时间也可以等被notify唤醒。
#继承Thread和实现Runnable两种创建线程的方式的区别
1、选择共享资源：
|-继承Thread：选择共享资源时，可能需要使用静态等方式，或者要考虑共享同一个对象的方式
|-实现Runnable：选择共享资源时，只要同一个Runnable的实现类即可
2、继承Thread，选择锁对象是，this对象不一定是对的，this可能不是同一个锁对象，可以考虑当前类的Class对象，或者是共享的资源对象。实现Runnable，选择锁对象时，this对象基本上没有问题。
3、继承Thread有单继承的限制，实现Runnable，没有单实现的限制
