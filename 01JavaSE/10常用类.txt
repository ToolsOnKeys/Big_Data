#抽象类
1、什么时候会用到抽象类
|-某个父类不想让你创建它的对象，哪怕它里面没有抽象方法，可以把这样的类声明为抽象类
|-某个父类中包含无法给出具体实现的抽象方法，那么这样的类必须声明为抽象类。（因为父类中需要体现它的子类们的共同特征，有些特征在父类中无法给出具体代码实现，不得不声明为抽象方法）
2、修饰符abstract
3、抽象类的特点
|-不能直接创建对象
|-包含抽象方法的类必须是抽象类
|-抽象类也可以没有抽象方法
|-抽象类也可以有属性、构造器等其他属性，他的构造器是给子类创建对象时调用
|-抽象类是用来被继承的，子类继承抽象类必须重写所有的抽象方法，否则子类也得是抽象类。
#多态
1、前提：继承、重写、多态引用
2、现象：这个父类变量在编译和运行时表现的类型不一致。编译时按照父类编译，只能调用父类中的方法，运行时执行的是子类重写的代码。
3、应用：
|-多态参数：方法的形参是父类的类型，调用时实参可以传入子类的对象
|-多态数组：元素的类型是父类的类型，给元素赋值时可以给子类的对象 
4、多态的好处：使得功能更加强大，更加灵活，可以使用父类的变量管理各种子类的对象
5、注意点：
|-属性没有多态：只看编译时的类型
|-静态方法没有多态：只看编译时的类型
#向上转型与向下转型
1、向上转型：当把子类的对象赋予父类的变量时，在编译时这个对象就被向上转型为父类的类型。但是运行时，仍然时子类的类型。
2、向下转型：
|-当把一个父类变量的值赋值给子类的变量时，就需要强制类型转换，向下转为子类的类型
|-这个转型是由风险的，可能发生ClassCastExecption
|-只有当这个父类的变量中实际存储的对象的类型<=被强转的子类类型，才能转换成功
|-我们可以使用instanceof来判断这个父类的变量存储的对象是否属于被强壮的子类的类型，来避免ClassCastException类型转换异常。
#关键字native
1、本地的、原生的；用来修饰方法
2、特点：
|-他的方法体的实现不是有Java语言实现的，而是由C等语言实现的。
|-我们在Java程序中调用时，可以当作普通的java方法一样调用，如果子类想要重写，只要这个antive方法不是static或final修饰的，子类就可以重写
|-native的方法运行时是在本地方法栈中开辟空间的
#内存管理
1、方法区：存储加载类的信息、静态变量、常量等
2、堆：new的对象
3、虚拟机栈：存储Java实现方法的局部变量
4、本地方法栈：存储native方法的局部变量
5、程序计数器：存储每一个线程的下一条指令
#根父类
1、根父类的理解：
①、所有引用该数据类型都将Object类视为我们的父类，可以是直接或间接的继承Object；
②、他的方法所有对象都拥有，包括数组对象。
③、Object类型的变量可以与任意类型的对象构成“多态引用”
④、所有对象的创建都会最终调用Object的无参构造
⑤、Object类型的数组可以存储任意类型的对象
2、根父类的常用方法：
①、toString（）：返回对象的信息
|-如果没有重写，默认返回的是“对象的运行时类型@对象的hashCode值的十六进制形式”
|-建议子类都要重写这个方法，并且用简单明了的形式来返回的对象的详细信息
|-如果我们打印对象或者一个对象与String进行凭借是就会自动调用一个对象的toString（）方法。
②、finalize（）：这个方法有GC垃圾回收期调用，在某个对象确定称为垃圾对象时调用，如果这个对象在finalize()方法后又被“复活”，下次称为垃圾后就不会再调用此方法，直接回收，一般建议资源对象过来重写这个方法用于彻底释放资源。
③、getClass（）：获取某个对象的运行时类型
④、clone（）：用于一个和当前对象给除了内存地址其他都一样的对象，但是要求这个类型必须实现java.lang.Cloneable接口。
⑤、hashCode（）：返回某个对象的hashCode值，hashCode值使用用于再哈希表等存储结构中存储对象是使用。
⑥、equals：判断当前对象this与指定对象gobj是否相等（没有重写，比较内存地址，重写了看重写的规则）【自反性，对称性，传递性，一致性，非空对象与null返回false】
【注：hashCode和equals方法重写的一些要求
|-必须同时重写，而且选择的比较的成员变量或者其他值要一样
|-equals返回true时，hashCode必须相同
|-hashCode可以一样，但是equals可能不一样
|-如果hashcode不一样，纳闷equals一定返回false】
#接口
1、接口的特点：
①、接口是不能直接实例化，即不能直接创建对象；
②、接口的成员：
|-JDK1.8之前：a、公共的静态的常量：public static final（可省略）；b、公共的抽象方法：public abstract（可以省略）；c、公共的静态的内部接口：public static(可以省略)
|-JDK1.8之后：a、公共的静态的方法：public static（static不可省略）；b、公共的默认方法：public default（default不能省略）
|-JDK1.9之后：a、接口是用来实现的，实现类实现接口时，要求必须重写接口的所有的抽象方法，否则这个实现类就是抽象类。b、Java中类与类之间有单继承限制，但是类与接口之间时支持多实现的。c、接口还可以继承接口，而且支持多继承。
2、默认方法的冲突问题：
①、当一个类同时实现了多个接口，多个接口可能存在方法签名相同的默认方法，此时要求实现类必须做出选择（选择保留其中一个接口的实现：接口名.super.方法；或者选择重写）
②、当一个类继承了父类，又实现了接口，父类中存在了方法签名与接口的默认方法相同的方法，此时这个子类有几个方案（子类默认保留的时父类的实现；我们也可以选择保留接口的实现：接口名.super.方法；选择完全重写）
3、两个和对象的比较大小有关的接口
①、java.lang.Comparable接口：自然排序-》compareTo（Obj）
②、java.util.Comparator接口：定制排序-》compare（obj1，obj2）
#内部类：
1、内部类的形式：
①、成员内部类：
|-静态内部类
|-非静态成员内部类
②、局部内部类
|-有名字的局部内部类
|-匿名内部类
2、内部类的选择：优先考虑静态内部类，但是当你的成员内部类中如果要用外部类的额非静态成员时，就不能使用静态内部类了。
#静态内部类 static
1、静态内部类的修饰符
①、四种权限修饰符
②、abstract
③、final
④、static
2、静态内部类也是一个类
①、可以继承自己的父类，实现自己的父接口们
②、成员没有限制
③、他又自己的字节码文件
3、静态内部类的使用问题：
①、在静态内部类中使用外部类的成员：有限制，只能用外部类的其他静态成员，不能使用外部类其他非静态成员。
②、在把外部类中使用静态内部类：无限制
③、在外部类的外面使用静态内部类：无限制
#非静态内部类
1、修饰符
①、四种权限修饰符
②、abstract
③、final
2、非静态内部类也是一个类
①、可以继承自己的父类，实现自己的父接口们
②、成员有限制（静态的常量，非静态的其他成员）
③、他有自己的字节码文件
3、非静态内部类的使用问题：
①、在非静态内部类中使用外部类的成员：没有限制
②、在外部类中使用非静态内部类：有限制，在外部类的静态成员中不能使用非静态的内部类
③、在外部类的外面使用非静态内部类：调用非静态内部类的非静态方法（获取内部类对象时，一般会在外部类中提供一个方法获取非静态内部类的对象，然后再外部类的外面通过外部类对象获取内部类对象）
#局部内部类
1、修饰符
①、abstract
②、final
2、局部内部类也是一个类：
①、可以继承自己的父类，实现自己的父接口们
②、成员有限制（静态的常量，非静态的其他成员）
③、有自己的字节码文件
3、局部内部类的使用问题
①、在局部内部类中使用外部类的成员：有限制（局部内部类所在方法是否时静态的）
②、外部类中使用局部内部类：有作用域限制
③、外部类的外面不能直接使用局部内部类
④、外部类的外面获取局部内部类的对象：可以通过方法的返回值，把这个对象放回去，用具不能不累的父类或子接口的变量接收这个对象。
⑤、再局部内部类中使用外部类的额局部变量：这个局部变量需要有final修饰，即常量。因为这个局部变量的值不能存在栈中。
#内名内部类：
1、使用：
①、内名内部类必须再声明类的同时就创建对象，他的对象时唯一的
②、在声明类并创建对象的同时，知名他的父类或父接口，并且通过（）中的参数来明确调用父类的那个构造器
2、内名内部类也是一个类
①、可以继承自己的父类，实现自己的父接口（new后面写了父类，就不能写接口，如果写了接口，直接父类就是Object）
②、成员有限制：静态的常量；非静态的其他成员
③、有自己的字节码文件
3、内名内部类的三种形式
①、多态引用：通过这种形式只能调用重写的父类的方法
②、用匿名内部类的匿名对象直接调用方法
③、用匿名内部类的匿名对象作为方法的实参
