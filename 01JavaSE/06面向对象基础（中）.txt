#面向对象的基本特征
封装；继承；多态
#封装
1、好处：设计者更安全、更可控；使用者更方便
2、如何实现封装：
|-通过对类、成员等设置不同的可见性范围
|-原则：暴露该暴露的，隐藏该隐藏的。暴露的程度依赖于权限修饰符。
3、权限修饰符可以修饰什么
|-外部类：public或缺省
|-成员：成员变量（属性）、成员方法、构造器、成员内部类四种权限修饰符都可以
4、通常属性的封装是什么样的：
当然属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，都是给private，然后给他们提供公共的get/set方法。
#构造器
1、构造器的作用：
|-和new一起是使用，创建实例对象
|-在创建对象的同时为属性初始化（有参构造）
2、构造器的特点：
|-构造器的名称必须与类名相同
|-构造器没有返回值类型
|-每个类都应该有构造器，如果程序员没有手动编写，那么编译器会自动生产一个默认的无参构造；如果程序员编写了构造器，那么无参构造也需要手动编写，否则不会自动增加。
|-构造器可以重载
|-默认生成的无参构造的权限修饰符同类的权限修饰符一致。
#关键字this
1、当前对象
|-在构造器中，this代表的是你正在与new的实例对象
|-在成员方法中，this代表的是调用当前方法的对象
2、this的用法：
|-this.属性：但局部变量和成员变量同名时
|-this.方法：可以省略
|-this()、this(实参列表)：必须放在构造器的首行。
3、成员变量和局部变量的区别：
|-声明的位置不同
|-在内存中的存储的位置不同：成员变量（堆中）、局部变量（栈中）
|-作用域：成员变量（本类中直接使用，其它类中通过“对象”）、局部变量（有作用域，超出作用域就不能使用，同一个作用域内不可同名，作用范围在{}内）
|-生命周期：成员变量（与它所属的对象同生共死，每个对象都是独立的）、局部变量（与方法的调用同生共死，每次方法的调用都是独立的。）
|-修饰符：成员变量（可以使用权限修饰符等）、局部变量（不能使用权限修饰符）
#包
1、包的作用：
|-避免类的同名
|-控制某些类或成员的可见性
|-组织管理不同的类
2、声明包的语法格式：
|-必须在.java的源文件的代码首行
|-包名：全为小写，所有单词之间使用.分割
|-习惯用共死域名倒置+模块名称
3、使用其他包的类
|-使用方法的全名称
|-使用import导包
4、import 包名.*
|-当使用两个不同包的同名类时，最多只能有一个使用导包语句，其他只能使用全名称
|-java.lang包下的类型不需要导包，就可以直接使用简名称
#关键字static
1、静态的
2、修饰符
|-成员变量
|-方法
|-代码块
|-成员内部类
3、static修饰成员变量，称为类变量或静态变量
|-在内存中存储在方法区
|-静态变量不单独属于某个对象，是所有对象共享的
|-他的get/set也是静态的
|-在静态的set方法等静态方法中，出现了局部变量与静态变量同名是，那么就用“类名.”进行区分
|-静态变量一般不在构造器中为他初始化，一般静态代码块中或显示赋值初始化。
4、static修饰方法，称为类方法或静态方法
|-静态方法，我们可以使用“类名.”进行调用。虽然也可以使用“对象.”进行调用
|-静态方法中，不允许出现：this、对本类非静态成员的引用、super等
#常用工具类
1、java.lang.Math类：此类中的方法、常量都是静态的，与数学计算有关
|-PI：圆周率
|-sqrt（x）：求平方根
|-random（）：返回【0，1）范围的随机数
|-pow（x，y）：求x的y次方
|-ceil（x）：向上取整
|-floor（x）：向下取整
|-round（x）：四舍五入
|-max（x，y）：最大值
|-min（x，y）：最小值
2、java.util.Arrays类：这个类中的方法也是静态的，都和数组的操作有关。
|-binarySearch（数组，要查找的值）：使用二分查找某个数组中某个值的下标。返回值如果是负数表示没有这个值，且要求待用此方法的数组必须是有序的。
|-copyOf（原数组，新数组的长度）：从原数组的[0]开始复制，得到一个新数组返回。
|-copyOfRange（原数组，起始下标，终止下标）：从原数组的起始下标开始复制到终止下标，将复制的值返回到一个新的数组中
|-fill（数组，值）：用这个值把数组填满
|-equals（数组1，数组2）：当两个数组的长度和元素都一致时返回true
|-sort（数组）：数组按照升序的顺序排序
|-toString（数组）：把数组的元素的值拼接成一个字符串返回；样式[元素1，元素2.....]
3、java.lang.System类：这个类中的方法也是静态的，都是和系统常用的功能有关的
|-静态的常量对象：①、System.in：默认情况是键盘输入；②、System.out：默认情况是输出到控制台；③、System.err：默认情况输出到控制台（一般输出的是错误信息）
|-System.arraycopy（原数组，原数组的起始下标，目标数组，目标数组的起始下标，一共要复制或移动的几个元素）
|-System.currentTimeMillis()：返回当前系统距离1970的毫秒值
|-System.exit(0)：0代表正常退出，非0代表异常终止。
#继承
1、继承的好处和目的：代码复用、代码功能的扩展
2、什么情况下会考虑使用继承：
|-当你声明一个类，发现已有的某个类中的所有的特征，在你的这个新类中都有，并且新的类型与已有类型是is-a的关系，纳闷可以考虑继承这个已有的类，避免编写重复的代码。在新的类型中增加已有的类没有的部分，实现功能的扩展。
|-当你同时编写多个类，发现这多个类中有共同的特性，那么此时可以考虑把这个鞋共同特性抽取到父类中，实现代码的讲话，从而也实现符类管理众多的子类对象。
3、继承的特点：
|-父类中所有的属性和方法都会被继承，但是私有的（如果跨包的化，缺省的）等这些在子类中是不可见的，在子类中无法直接使用，我们可以间接使用它。
|-父类中的构造器是不能被继承的。
|-但是子类的构造器中必须调用符类的构造器，目的就是为从符类继承的属性进行初始化。
|-Java中的继承有单继承的显示，即直接父类只能由一个
|-但是Java支持多层继承，即父类还可以有父类
|-一个父类可以同时拥有多个子类
4、方法的重写Override
|-当子类继承父类，父类的某个方法的实现（方法体）不适用于子类，那么子类就可以选择重写
|-重写的方法名、形参列表、返回值（子类的类型<父类类型）必须相同
|-权限修饰符：>=
|-不能被重写的方法：final、static、private、跨包缺省的
#super
1、父类的：当前子类对象中，访问父类中声明的属性、方法、构造器
2、前提：不管你是通过super去访问什么，都要保证这个成员在子类中是可见的。
3、用法的三种：
|-super.属性：子类中声明了与父类同名的属性，并且父类这个属性在子类可见，那么为了区别，就需要super.属性代表父类中继承的属性
|-super.方法：当子类重写了父类的某个方法，又想要在子类中调用被重写的方法，那么可以使用super.方法代表父类中被重写的方法
|-super()或super(实参列表)：子类构造器的首行一定回调用父类的构造器。
#关键字final
1、最终的
2、修饰类：表示这个类不能被击沉，即不能有子类；常见的有String、System、Math
3、修饰方法：表示这个方法不能被重写
4、修饰变量：表示这个变量的值不能被修改，称为常量；常量的命名一般是所有字母都是大写的
