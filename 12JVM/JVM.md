# JVM

## JVM体系结构
>+ Class files ==> Class loader（类加载器）
>+ ==>运行时数据区（方法区、堆、java栈、本地方法区、程序计数器）
>+ ==>执行引擎==>本地方法接口<==本地方法库

## 类加载器
  负责class文件的加载，至于他是否可以运行由执行引擎决定。
  class文件再文件开头有特定的文件表示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。
+ 启动类加载器
C++
``` java
  Object.getClass().getClassLoader()
```
> 后台返回 null
+ 扩展类加载器
Java
> sun.misc.Launcher$ExtClassLoader@
+ 应用程序类加载器
加载当前应用的classpath的所有类
> sun.misc.Launcher$AppClassLoader@
+ 用户自定义加载器（用户自定义，一般用不到）
java.lang.ClassLoader的子类，用户可以定制类的加载器
### 双亲委派机制 + 沙箱安全机制
类的加载从上往下加载类，如果一直到应用数据类加载器没有加载到，报类加载失败的错误。

## 本地方法库 -> 本地方法接口 -> 本地方法栈 【native】
+ 修饰符，有方法声明但是无方法实现（方法实现依赖于第三方语言）

## 程序计数器（Program Counter Register）
+ 记录方法的调用和执行情况

## 方法区
+ 所有线程共享；
+ 存在垃圾回收（较少）；
+ 存储每个类的结构信息；
（例如：运行时常量池、字段和方法数据、构造函数和普通方法和字节码内容）
>* 注意：以上时规范，再不同虚拟机里面实现是不一样的，最典型的是永久代（PerGen space）和元空间（Metaspace）

## 栈 stack
+ 主管Java程序的运行
+ 线程私有
+ 无垃圾回收
+ 8种基本数据类型+对象的引用变量+实例方法
+ StackOverflowError 栈溢出错误
### 栈帧
实例的方法
+ 本地变量：输入参数，输出参数，和方法内的变量
+ 栈操作：记录出栈和入栈的操作
+ 栈帧数据：包括类文件、方法等等

> 栈管运行，堆管存储
> 程序 = 算法 + 数据结构 ==》框架+业务逻辑

## 堆 heap
+ OutOFMemoryError 堆溢出错误：FGC清理之后仍然，养老区溢出
### 新生区 1/3
> YGC（MinorGC）: 复制（伊甸区+幸存0区的幸存者复制到幸存1区同时幸存者幸存指数+1） - 清空（清空伊甸区和幸存0区） -交换（幸存0区和幸存1区交换【检查幸存指数，幸存指数=15时，会将幸存者放入老年区】）
+ 伊甸区 8/10
+ 幸存者0区 1/10
+ 幸存者1区 1/10
### 老年区 2/3
### 元空间（JDK1.8）/永久区（JDK1.7）
【jar包】：无回收GC，只有在程序结束，才会释放
