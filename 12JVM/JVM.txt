JVM
	
#JVM的作用
在运行Java程序之前，我们需要对其进行一番转换；转换的过程为通过编译器将Java程序转换成虚拟机所能识别的指令序列，也成为Java字节码。Java虚拟机会见字节码，即class文件加载到jvm中。由JVM进行解释和执行。
JVM是运行在操作系统之上的，他与硬件没有直接的交互。
	
#
在虚拟机中，方法区和堆为线程共享的，也是垃圾回收的重点照顾区域。占空间为线程私有，基本不会出现垃圾回收。
Java虚拟机将栈细分为面向Java方法和Java方法栈，面向本地方法的本地方法栈，以及存放每个线程执行位置的PC寄存器。
	
#类加载器
1、类加载器，即ClassLoader，它负责加载class文件，class文件在文件开头由特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
2、类加载器的分类：
①、启动类加载器：主要负责加载jre中最基础、最为重要的类。rt.jar;由于他是由C++代码实现的，没有对应的java对象，因此在java中，尝试获取此类时，只能用null指代。
②、扩展类加载器：由Java代码实现，用于加载相对次要、但有通用的类；在jre的lib/ext目录下jar包中的类。
③、应用程序加载器：由java代码实现，它负责加载应用程序路径下的类；
④、用户自定义加载器：
	
#PC寄存器（程序计数器）
每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
PC寄存器主要负责计数和调度。它可以看作是当前线程所执行的字节码的行号指示器。由于Java虚拟机的多线程是图哦那个过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都会由一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。
	
#方法区
方法区是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区属于共享区间。
静态变量+常量+类信息（构造方法/几口定义）+运行时变量池存在方法区中。
实例变量存在堆内存中，和方法区无关。
	
#栈
1、栈，也叫栈内存，主管Java程序的运行，是在线程创建时创建，他的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就结束，生命周期和线程一致，是线程私有的。
一个线程中的每个方法在执行的哦同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。8种基本类型的变量+对象的引用变量+实例方法都是在行数的栈内存中分配。
在栈区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
2、栈帧
一个线程的每个方法在调用时都会在掌上划分一块区域，用于存储方法所需要的变量等信息，这块区域称之为栈帧。栈由多个栈帧构成。
3、栈的运行原理
①、栈中的数据都是以栈帧为载体存在。在栈中，方法的调用顺序遵循“先进后出”原则。
②、每执行一个方法都会产生一个栈帧，保存到栈的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈出栈。
③、栈帧中主要保存3类数据：
|-本地变量：
|-栈操作
|-栈帧数据
	
#堆、栈、方法区交互关系
HotSpot时使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，reference存储的就直接时对象的地址。
	
#堆-逻辑设计
1、堆是Java虚拟机所管理的内存中最大的一块，时被所有线程共享的一块内存区域，在虚拟机启动时创建。堆内存的大小是可以调节的
2、所有的对象实例以及数组都要在堆上分配
3、如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常
4、Java堆时垃圾收集器管理的主要区域，因此也被称为“GC堆“
5、堆内存分为三个部分
①、新生区
②、养老区
③、永久区
|-是一个常驻内存区域，用于存放JDK自身携带的Class、Interface的元数据，也就是说它存储的是运行环境必须的类信息，被转载进此区域的数据是不会被垃圾回收期回收掉的，关闭JVM才会释放此区域所占用的内存。
	
#GC
1、它会不定时去堆内存中清理对象
2、垃圾回收再一个Java程序中的执行是自动执行的，不受外界干扰的。程序员唯一能做的就是通过调用System.gc（）方法来”建议“执行垃圾收集器，当其是否可以执行，什么时候执行却都是不可知的。这就是垃圾收集器的最主要的缺点。当然相对于他给程序员带来的巨大方便性而言，这个缺点是瑕不掩瑜的。
3、finalize（）：java技术使用finalize（）方法在垃圾收集器将对象从内存中清理出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。他是Object类中定义的的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者执行其他清理工作。
4、标记不可达对象的方式：
①、引用计数法
②、GC ROOTS算法
5、垃圾回收的方式
①、清除：把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象（缺点：造成难以利用的磁盘碎片）
②、压缩：可以解决磁盘碎片，但是压缩算法会增加性能开销
③、复制：把内存区域分为两个等分，分别用from和to来维护，并且只是from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域，并且交换from指针和to指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是他的缺点也极其明显，即堆空间的使用效率极其低下。
【总结】：回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清楚、性能开销较大的压缩、以及堆使用效率较低的复制。当然，现代的垃圾回收器往往会综合上述几种回收方式，综合他们的优点的同时规避他们的缺点。
	
#垃圾回收算法
1、标记复制算法
新生代GC使用的是标记复制算法。
2、标记清除算法
一般应用于老年代，该算法相对所有可访问的对象，做个标记在遍历堆，把未标记的对象回收 。
缺点：回收时，引用需要挂起，导致用户体验差，由于需要便利全堆对象，效率低；易造成内存碎片化
3、标记压缩算法：
标记清楚算法和标记压缩算法非常类似，但是标记压缩算法在标记清楚算法之上解决了内存碎片化；
优点：解决内存碎片化问题，也消除了复制算法当中，内存减半的高额代价
缺点：效率低，压缩阶段，由于移动了可用对象，需要去更新引用
4、标记清除压缩算法：
是标记清除算法和标记压缩算法的结合算法。其原理和标记清除算法一致，只不过会在多次GC后，进行一次Compact操作。
	
#垃圾回收器
1、串行回收和并行回收
|-串行回收：JDK1.5前的默认算法，缺点时只有一个线程，执行垃圾回收时程序停止的时间较长
|-并行回收：多个线程执行垃圾回收适合于高吞吐量的系统，回收时系统会停止运行
2、Serial串行收集器：古老稳定且效率高的收集器，是一个单线程的收集器，在进行垃圾收集的时候，必须暂停其他所有的工作线程直至它收集结束。
特点：CPU利用率高，停顿时间长
使用场景：小型应用
3、Parallel New收集器：Serial串行收集器的多线程版本。新生代并行，老年代串行；新生代采用复制算法，老年代使用标记-压缩算法
4、Parallel Scavenge收集器
更关注系统的吞吐量。特点：停顿时间短，回收效率高，对吞吐量要求高；适用场景：大型引用，科学计算，大规模数据采集
5、cms收集器：
并发收集、低停顿；产生大量空间碎片、并发阶段会降低吞吐量；采用标记清除算法实现，使用多线程的算法去扫描堆，堆发现未使用的对象进行回收。
6、G1收集器：
支持很大的堆，高吞吐量；支持多CPU和垃圾回收线程；在主线程暂停的情况下，使用并行收集；在主线程运行的情况下，使用并发收集。