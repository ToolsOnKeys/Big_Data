# 隐式转换

## 1、隐式转换

### ①、基本介绍

* 隐式转换行式是以implicit关键字声明的带有单个参数的函数。这种函数将会自动引用，将值从一种类型转换为另一种类型

### ②、注意事项和细节

* 隐式转换函数的函数名可以是任意的额，隐式转换于函数名称无关，制语函数签名（函数参数类型和返回值类型）有关
* 隐式函数可以有多个，但是需要保证在当前环境下，只有一个隐式函数能被识别

## 2、隐式转换丰富类库功能

### ①、基本介绍

* 如果要为一个类增加一个方法，可以通过隐式转换来事项。（动态增加功能）

### ②、分析解决方案

* 在实际项目中，如果想要增加新的功能就会需要改变源代码，违背了软件开发的OCP开发原则（开闭原则）；这种情况下，可以通过隐式转换函数添加功能

## 3、隐式值

### ①、基本介绍

* 隐式值也叫隐式变量，将某个形参变量标记为implicit，所以编译器会在方法省略隐式参数的情况下去搜索作用域内的隐式值作为缺省参数
* 隐式值只能有一个
* 实参>隐式值>默认值

## 4、隐式类

### ①、基本介绍

* 在Scala2.10后提供了隐式类，可以使用implicit声明类，隐式类非常强大，同样可以扩展类的功能，比前面使用隐式转换丰富类库功能更加的方便，在集合中隐式类会发挥重要的作用

```scala
implicit val str1: String = "jack"
def hello(implicit name: String): Unit = {
println(name + " hello")
}
hello
```

### ②、隐式类的特点

* 其所在的构造参数有且只有一个
* 隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶级的
* 隐式类不能是case class（样例类）
* 作用域内不能有与之相同名称的标识符

```scala
class MySQL1 {
  def sayOk(): Unit = {
    println("sayOk")
  }
}
def main(args: Array[String]): Unit = {
    //DB1会对应生成隐式类
    implicit class DB1(val m: MySQL1) {
      def addSuffix(): String = { //方法
        m + " scala"
      }
    }
    val mysql1 = new MySQL1 //创建一个 MySQL1
    mysql1.sayOk()
    println(mysql1.addSuffix()) // 
  }//案例演示+说明
```

## 5、隐式转换时机

* 当方法中的参数的类型与目标类型不一致时
* 当对象调用所在类中不存在的方法或成员时，编译器会自动将对象进行隐式转换（根据类型）

## 6、隐式解析机制

* (1)      首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）。(一般是这种情况)
* (2)      如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生模块，一个隐式实体的类型T它的查找范围如下(第二种情况范围广且复杂在使用时，应当尽量避免出现)：
  * a)  如果T被定义为T with A with B with C,那么A,B,C都是T的部分，在T的隐式解析过程中，它们的伴生对象都会被搜索。
  * b)  如果T是参数化类型，那么类型参数和与类型参数相关联的部分都算作T的部分，比如List[String]的隐式搜索会搜索List的伴生对象和String的伴生对象。
  * c)  如果T是一个单例类型p.T，即T是属于某个p对象内，那么这个p对象也会被搜索。
  * d)  如果T是个类型注入S#T，那么S和T都会被搜索